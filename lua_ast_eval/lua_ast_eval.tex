%% LyX 2.1.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{babel}
\begin{document}
We specify below the behavior of toAST() and compile() by using the
formalization of a subset of Lua semantics, as presented (as Lua Core)
in \cite{terra}. This subset captures the notions of lexing scoping,
closures and side-effects and is therefore sufficient for our purposes.
We extend the Lua Core specification from \cite{terra} with a general
``binary operator'' expression, mimicking Lua operators supported
by LuaToAST.

Lua Core syntax is presented as follows:

\[
e=b\,|\, x\,|\,\mbox{let \ensuremath{x=e}in \ensuremath{e}}\,|\, x\coloneqq e\,|\, e(e)\,|\,\mbox{fun}(x)\{e\}\,|\, e\mbox{ op }e\,|\,\mbox{toAST}(e)\,|\,\mbox{compile}(a)
\]


Lua expressions can be base values ($b$), variables ($x$), a scoped
variable definition ($\mbox{let \ensuremath{x=e}in \ensuremath{e}}$,
with $e;e$ as sugar for $\mbox{let \ensuremath{\_=e}in \ensuremath{e}}$),
a variable assignment ($x\coloneqq e$), an application ($e(e)$),
a function definition ($\mbox{fun}(x)\{e\}$) or an operation on expressions
($e\mbox{ op }e$, with semantics defined by the function $Op$).
We extend this by adding operations toAST($e$) and compile($a$).

\[
v=b\,|\,\left\langle \Gamma,x,e\right\rangle \,|\, a
\]


Lua values can be base values ($b$), closures ($\left\langle \Gamma,x,e\right\rangle $)
or Lua ASTs ($a$).

\[
a=[\mbox{base \ensuremath{b}}]\,|\,[\mbox{closure }\left\langle \Gamma,x,e\right\rangle ]\,|\,[\mbox{op \ensuremath{a}\ensuremath{a}}]
\]


A Lua AST may contain nodes that wrap base values\emph{ }(\emph{$[\mbox{base }b]$),
}closures ($[\mbox{closure }\left\langle \Gamma,x,e\right\rangle ]$)
and operations ($[\mbox{op }\, a\, a]$).

The rules for evaluating Lua expressions over an environment $\Sigma$,
which is a tuple $(\Gamma,S)$ containing a namespace $\Gamma:x\rightarrow p$
and a store $S:p\rightarrow v$ (where $p$ are memory positions)
are as follows. We use $\rightarrow$ instead of $\overset{L}{\rightarrow}$
as in \cite{terra}; where rules have the same names, they have the
same semantics as those presented in that work.

\[
v,\Sigma\rightarrow v,\Sigma\textsc{ (LVal)}
\]


\[
\frac{\Sigma=(\Gamma,S)}{x,\Sigma\rightarrow S(\Gamma(x)),\Sigma}\textsc{ (LVar)}
\]


\[
\frac{\begin{array}[t]{c}
e_{1},\Sigma_{1}\rightarrow v_{1},(\Gamma_{2},S_{2})\\
p\,\mbox{fresh}\,\,\,\,\,\,\,\,\,\, e_{2},(\Gamma_{2}[x\leftarrow p],S_{2}[p\leftarrow v_{1}])\rightarrow v_{2},(\Gamma_{3},S_{3})
\end{array}}{\mbox{let \ensuremath{x=e_{1}}in \ensuremath{e_{2}}},\Sigma_{1}\rightarrow v_{2},(\Gamma_{2},S_{3})}\textsc{ (LLet)}
\]


\[
\frac{\begin{array}[t]{c}
e_{1},\Sigma_{1}\rightarrow\left\langle \Gamma_{1},x,e_{3}\right\rangle ,\Sigma_{2}\,\,\,\,\,\,\,\,\,\, e_{2},\Sigma_{2}\rightarrow v_{1},(\Gamma_{3},S_{3})\\
\mbox{\ensuremath{p}\, fresh}\,\,\,\,\,\,\,\,\,\, e_{3},(\Gamma_{1}[x\leftarrow p],S_{3}[p\leftarrow v_{1}])\rightarrow v_{2},(\Gamma_{4},S_{4})
\end{array}}{e_{1}(e_{2}),\Sigma_{1}\rightarrow v_{2},(\Gamma_{3},S_{4})}\textsc{ (LApp)}
\]


\[
\frac{e_{1},\Sigma_{1}\rightarrow v_{1},(\Gamma,S)\,\,\,\,\,\,\,\,\,\,\Gamma(x)=p}{x\coloneqq e,\Sigma\rightarrow v,(\Gamma,S[p\leftarrow v])}\textsc{ (LAsn)}
\]


\[
\frac{\Sigma=(\Gamma,S)}{\mbox{fun(\ensuremath{x})\{\ensuremath{e}\}},\Sigma\rightarrow\left\langle \Gamma,x,e\right\rangle ,\Sigma}\textsc{ (LFun)}
\]


\[
\frac{e_{1},\Sigma_{1}\rightarrow v_{1},\Sigma_{2}\,\,\,\,\,\,\,\,\,\, e_{2},\Sigma_{2}\rightarrow v_{2},\Sigma_{3}\,\,\,\,\,\,\,\,\,\, v_{3}=Op(v_{1},v_{2})}{e_{1}+e_{2},\Sigma_{1}\rightarrow v_{3},\Sigma_{3}}\textsc{ (LOp)}
\]


\[
\frac{e_{1},\Sigma\rightarrow\left\langle \Gamma,x,e_{2}\right\rangle ,\Sigma\,\,\,\,\,\,\,\,\,\, e_{2},\Sigma\overset{D}{\rightarrow}a_{1}}{\mbox{toAST(\ensuremath{e_{1}})},\Sigma\rightarrow a_{1},\Sigma}\textsc{ (LAst)}
\]


\[
\frac{\Sigma=(\Gamma,S)\,\,\,\,\,\,\,\,\,\, a_{1},\Sigma\overset{C}{\rightarrow}e_{1}}{\mbox{compile(\ensuremath{a_{1}})},\Sigma\rightarrow\left\langle \Gamma,\_,e_{1}\right\rangle ,\Sigma}\textsc{ (LComp)}
\]


The rules for decompiling Lua expressions ($\overset{D}{\rightarrow}$)
over an environment $\Sigma$ are the following:

\[
b,\Sigma\overset{D}{\rightarrow}[\mbox{base }b]\textsc{ (DBase)}
\]


\[
\frac{\Sigma=(\Gamma,S,F)}{x,\Sigma\overset{D}{\rightarrow}[\mbox{closure }\left\langle \Gamma,\_,x\right\rangle ]}\textsc{ (DVar)}
\]


\[
\frac{e_{1},\Sigma\overset{D}{\rightarrow}a_{1}\,\,\,\,\,\,\,\,\,\, e_{2},\Sigma\overset{D}{\rightarrow}a_{2}}{e_{1}\mbox{ op }e_{2},\Sigma\overset{D}{\rightarrow}[\mbox{op \ensuremath{a_{1}}\ensuremath{a_{2}}}]}\textsc{ (DOp)}
\]


Note that $\overset{D}{\rightarrow}$ is defined only for variables,
base values and the operator, mirroring the implementation of LuaToAST. 

Finally, the rules for compiling Lua ASTs ($\overset{C}{\rightarrow}$)
over an environment $\Sigma$ are:

\[
[\mbox{base \ensuremath{b}}],\Sigma\overset{C}{\rightarrow}b,\Sigma\textsc{ (CBase)}
\]


\[
\frac{\Sigma=(\Gamma,S)\,\,\,\,\,\,\,\,\,\, e_{1},(\Gamma_{1},S)\rightarrow v_{1},\Sigma_{2}}{[\mbox{closure }\left\langle \Gamma_{1},\_,e_{1}\right\rangle ],\Sigma\overset{C}{\rightarrow}v_{1}}\textsc{ (CVar)}
\]


\[
\frac{a_{1},\Sigma\overset{C}{\rightarrow}e_{1}\,\,\,\,\,\,\,\,\,\, a_{2},\Sigma\overset{C}{\rightarrow}e_{2}}{[\mbox{op \ensuremath{a_{1}}\ensuremath{a_{2}}}],\Sigma\overset{C}{\rightarrow}e_{1}\mbox{ op }e_{2}}\textsc{ (COp)}
\]


The evaluation of variables $x$ happens only at compilation time,
as evidenced by the evaluation of $e_{1}$ using $\rightarrow$ in
rule \textsc{CVar}. 
\begin{thebibliography}{1}
\bibitem{terra}DeVito et al. ''Terra: a multi-stage language for
high-performance computing'' PLDI'13.\end{thebibliography}

\end{document}
