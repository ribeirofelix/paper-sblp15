\section{Evaluation Semantics}
\label{sec:evaluation_semantics}

\begin{figure}
{\footnotesize{}}%
\begin{minipage}[t]{0.59\columnwidth}%
{\footnotesize{}
\[
v,\Sigma\rightarrow v,\Sigma\textsc{ (LVal)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\Sigma=(\Gamma,S)}{x,\Sigma\rightarrow S(\Gamma(x)),\Sigma}\textsc{ (LVar)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
e_{1},\Sigma_{1}\rightarrow v_{1},(\Gamma_{2},S_{2})\\
p\,\mbox{fresh}\\
e_{2},(\Gamma_{2}[x\leftarrow p],S_{2}[p\leftarrow v_{1}])\rightarrow v_{2},(\Gamma_{3},S_{3})
\end{array}}{\mbox{let \ensuremath{x=e_{1}}\,\ in\,\ensuremath{e_{2}}},\Sigma_{1}\rightarrow v_{2},(\Gamma_{2},S_{3})}\textsc{ (LLet)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
e_{1},\Sigma_{1}\rightarrow\left\langle \Gamma_{1},x,e_{3}\right\rangle ,\Sigma_{2}\\
e_{2},\Sigma_{2}\rightarrow v_{1},(\Gamma_{3},S_{3})\\
\mbox{\ensuremath{p}\,\ fresh}\\
e_{3},(\Gamma_{1}[x\leftarrow p],S_{3}[p\leftarrow v_{1}])\rightarrow v_{2},(\Gamma_{4},S_{4})
\end{array}}{e_{1}(e_{2}),\Sigma_{1}\rightarrow v_{2},(\Gamma_{3},S_{4})}\textsc{ (LApp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e_{1},\Sigma_{1}\rightarrow v_{1},(\Gamma,S)\,\,\,\,\,\,\,\,\,\,\Gamma(x)=p}{x\coloneqq e,\Sigma\rightarrow v,(\Gamma,S[p\leftarrow v])}\textsc{ (LAsn)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\Sigma=(\Gamma,S)}{\mbox{fun(\ensuremath{x})\{\ensuremath{e}\}},\Sigma\rightarrow\left\langle \Gamma,x,e\right\rangle ,\Sigma}\textsc{ (LFun)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
e_{1},\Sigma_{1}\rightarrow v_{1},\Sigma_{2}\,\,\,\,\,\,\,\,\,\, e_{2},\Sigma_{2}\rightarrow v_{2},\Sigma_{3}\\
v_{3}=Op(v_{1},v_{2})
\end{array}}{e_{1}\mbox{\,\ op\,}e_{2},\Sigma_{1}\rightarrow v_{3},\Sigma_{3}}\textsc{ (LOp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e_{1},\Sigma\rightarrow\left\langle \Gamma,x,e_{2}\right\rangle ,\Sigma\,\,\,\,\,\,\,\,\,\,\left\langle \Gamma,x,e_{2}\right\rangle ,\Sigma\overset{D}{\rightarrow}a}{\mbox{toAST(\ensuremath{e_{1}})},\Sigma\rightarrow a,\Sigma}\textsc{ (LAst)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\Sigma=(\Gamma,S)\,\,\,\,\,\,\,\,\,\, a,\Sigma\overset{C}{\rightarrow}e}{\mbox{compile(\ensuremath{a})},\Sigma\rightarrow e,\Sigma}\textsc{ (LComp)}
\]
}%
\end{minipage}{\footnotesize{}}%
\begin{minipage}[t]{0.4\columnwidth}%
{\footnotesize{}
\[
b,\Sigma\overset{D}{\rightarrow}[\mbox{base }b]\textsc{ (DBase)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\Sigma=(\Gamma,S,F)}{x,\Sigma\overset{D}{\rightarrow}[\mbox{var }\left\langle \Gamma,\_,x\right\rangle ]}\textsc{ (DVar)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e_{1},\Sigma\overset{D}{\rightarrow}a_{1}\,\,\,\,\,\,\,\,\,\, e_{2},\Sigma\overset{D}{\rightarrow}a_{2}}{e_{1}\mbox{ op }e_{2},\Sigma\overset{D}{\rightarrow}[\mbox{op\,\ensuremath{a_{1}\,}\ensuremath{a_{2}}}]}\textsc{ (DOp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e,\Sigma\overset{D}{\rightarrow}a}{\left\langle \Gamma,x,e\right\rangle ,\Sigma\overset{D}{\rightarrow}[\mbox{fn }x\, a]}\textsc{ (DFn)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
[\mbox{base \ensuremath{b}}],\Sigma\overset{C}{\rightarrow}b,\Sigma\textsc{ (CBase)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
\Sigma=(\Gamma,S)\\
e_{1},(\Gamma_{1},S)\rightarrow v_{1},\Sigma_{2}
\end{array}}{[\mbox{var }\left\langle \Gamma_{1},\_,e_{1}\right\rangle ],\Sigma\overset{C}{\rightarrow}v_{1}}\textsc{ (CVar)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{a_{1},\Sigma\overset{C}{\rightarrow}e_{1}\,\,\,\,\,\,\,\,\,\, a_{2},\Sigma\overset{C}{\rightarrow}e_{2}}{[\mbox{op\,\ensuremath{a_{1}}\ensuremath{\, a_{2}}}],\Sigma\overset{C}{\rightarrow}e_{1}\mbox{ op }e_{2}}\textsc{ (COp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{a,\Sigma\overset{C}{\rightarrow}e}{[\mbox{fn }x\, a],\Sigma\overset{C}{\rightarrow}\left\langle \Gamma,x,e\right\rangle }\textsc{ (CFn)}
\]
}%
\end{minipage}{\footnotesize \par}

\protect\caption{Rules $\rightarrow$ for the evaluation of Lua expressions, $\protect\overset{D}{\rightarrow}$
for decompiling Lua expressions into ASTs, and $\protect\overset{C}{\rightarrow}$
for compiling ASTs back into expressions.}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We specify below the behavior of toAST() and compile() by using the
formalization of a subset of Lua semantics, as presented (as Lua Core)
in \cite{DeVito2013Terra}. This subset depicts the notions of lexical scoping,
closures and side-effects and is therefore sufficient for our purposes.
We extend the Lua Core specification from \cite{DeVito2013Terra} with a general
``binary operator'' expression, mimicking Lua operators supported
by LuaToAST.

Lua Core syntax is presented as follows:

\[
e=b\,|\, x\,|\,\mbox{let \ensuremath{x=e}\,\ in\,\ensuremath{e}}\,|\, x\coloneqq e\,|\, e(e)\,|\,\mbox{fun}(x)\{e\}\,|\, e\mbox{ op }e\,|\,\mbox{toAST}(e)\,|\,\mbox{compile}(a)
\]


Lua expressions can be base values ($b$), variables ($x$), a scoped
variable definition ($\mbox{let \ensuremath{x=e}\,\ in\,\ensuremath{e}}$,
with $e;e$ as sugar for $\mbox{let \ensuremath{\_=e}\,\ in\,\ensuremath{e}}$),
a variable assignment ($x\coloneqq e$), an application ($e(e)$),
a function definition ($\mbox{fun}(x)\{e\}$) or an operation on expressions
($e\mbox{ op }e$, with semantics defined by a function $Op$). We
extend this by adding operations toAST($e$) and compile($a$).

\[
v=b\,|\,\left\langle \Gamma,x,e\right\rangle \,|\, a
\]


Lua values can be base values ($b$), closures ($\left\langle \Gamma,x,e\right\rangle $)
or Lua ASTs ($a$).

\[
a=[\mbox{fn\,\ensuremath{x}\,\ensuremath{a}}]\,|\,[\mbox{base \ensuremath{b}}]\,|\,[\mbox{var }\left\langle \Gamma,x,e\right\rangle ]\,|\,[\mbox{op\,\ensuremath{a}\,\ensuremath{a}}]
\]


A Lua AST for a function consists of a root node ($[\mbox{fn\,\ensuremath{x}\,\ensuremath{a}}]$)
which may contain nodes that wrap base values\emph{ }($[\mbox{base }b]$\emph{),
}variables ($[\mbox{var }\left\langle \Gamma,x,e\right\rangle ]$)
and operations ($[\mbox{op}\, a\, a]$).

The rules for evaluating Lua expressions over an environment $\Sigma$,
which is a tuple $(\Gamma,S)$ containing a namespace $\Gamma:x\rightarrow p$
and a store $S:p\rightarrow v$ (where $p$ are memory positions)
are as follows. We use $\rightarrow$ instead of $\overset{L}{\rightarrow}$
as in \cite{DeVito2013Terra}; where rules have the same names, they have the
same semantics as those presented in that work.
