\documentclass[english]{llncs}

\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{babel}

\title{Embedding Languages While Preserving Lexical Scoping}

\author{
Félix Ribeiro,
Hisham Muhammad,
André Murbach Maidl,
Roberto Ierusalimschy
}

\institute{
Department of Computer Science --
PUC-Rio -- Rio de Janeiro -- Brazil
\email{\{fribeiro,hisham,amaidl,roberto\}@inf.puc-rio.br}
}

\begin{document}

\maketitle

\begin{abstract}

There are various situations in which one may want to embed source code from
one language into another, for example when combining relational query
languages with application code or when performing staged meta-programming.
Typically, one will want to transfer data between these languages.
We propose an approach in which the embedded code shares variables with the
host language, preserving lexical scoping rules even after the code is
converted into an intermediate representation. We demonstrate this approach
through a module for metaprogramming using Lua as both embedded and host
languages, which decompiles Lua functions to their AST form and can later
rebuild them preserving scoping rules of the decompilation site. Our method
requires no special annotation of functions to be translated and is
implemented as a library, requiring no source pre-processing or changes to
the host language execution environment.

\keywords{
Lua,
Domain Specific Languages,
Embedded Languages
}
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lua2AST}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Lua2AST is a Lua module that takes a restricted form of Lua function, that we named lambda functions, and generates its AST in runtime.
Lambda functions is defined here as functions that only contains the return statement.
The expression contained in the return statement can be of any kind and can also use variables of the outer lexical scope.
In Lua, this kind of variables are called upvalues.
The process of generation uses externs libraries: luadec and lua-parser.
Luadec\cite{TODO} is a Lua decompiler that takes a Lua binary chunk and returns a string with equivalent code.
Lua-parser\cite{TODO} generates a Lua AST from a string with a valid Lua code.

%% TODO : detalhar o pq do uso do luadec - diferenciar dos related works
%% explicitando as vantagens de utilizar o LuaDec
%% Menos intruzivo no codigo fonte(nao precisam ser anotadas) e mais no background
%% nao tem modificacao na virtual machine 
%% linguagem eh dinamica - ela tem eval (alem de ser dinamicamente tipada) - facilidade provida pela linguagem
%% nossa abordagem ela integra bem com as caracteristicas dinamicas da linguagem
%% o q nao seria possivel se fosse feita atraves de preprocessador
%% pontuar q o processo inteiro ocorre em tempo de execucao
This module contains two principal functions: toAST e compile.
The first one generates an AST and the second one compiles an AST.

\subsection{Function toAST(func) }

The parameter func must be a lambda function.
The function's return is a Lua table that represents an AST.
If the received function uses upvalues the returned table will be an annotated AST,so that the upvalues can be evaluated properly.

The toAST(func) function calls the function luadec(arg) that belongs to libluadec, sending the function that will be transformed in AST as argument.
The return of the luadec(arg) is a string that represents the passed function code.
This string is sent to the parse function of lua-parser library and it returns the AST that represents the code.

The received AST is traversed once.
Firstly we find the parameters of the function and store them in a set.
Later, we localize the free variables of the  function and when they are found a execution code lookup is made with the standard library debug.

The lookup consists in going through the upvalues that belongs to the function that was sent to toAST in order to find the variable of the same name.
When the variable is found, we do the AST annotation process.

To do this annotation in our AST we use the function upvaluejoin, that also belongs to the debug library.
This function joins two upvalues of distinct functions.
But, to use this function, we need another one to join the upvalues. To do so, we created the functions that follows:


\begin{verbatim}
local function newclosure()
    local temp
    return function () return temp end
end
\end{verbatim}

So, when an upvalue is found, the newclosure function is called, then its return is assigned to a variable and the found upvalue is joint to the temp upvalue.
After pulling them together, we generate an unique identifier to the function returned by newclosure.
We replace in the AST the node that identifies the free variable by an upvalue node.
In this node is inserted the function with unique identifier generated by upvalue.


The following example illustrates the use of the toAST function:


\begin{verbatim}
local last = require "lua-to-AST"

local y = 1
ast = last.toAST(function(x) return x + y end )
last.print(ast)
\end{verbatim}


The program's output will be the AST print, as below:
%% Verificar higienizacao de variaveis
\begin{verbatim}
{ `Function{ { `Id "x" },
      { `Return{ `Op{ "add", `Id "x", `UpValue "clo_0"}}}}}}
\end{verbatim}


\subsection{Function compile(ast) }


%% completar exemplo da secao anterior
%% mostrar string interna 
This function receives as argument the AST generated by toAST and returns the function that this AST describes.

The AST received is encapsulated in a return node and then a string with correspondent Lua code is generated.Using the AST above to examplify, its correspondent string would be as follows:


%% TODO : higenizacao
\begin{verbatim}
"function(x) return x + closures["clo_0"]() end"
\end{verbatim}

This string is sent to the loadstring function.
The function compile returns the result of loadstring.
In this way the user can utilize the returned function that is the compilation of the AST.
Bellow we show an example of using the compile function, it uses the AST that was previously generated.


\begin{verbatim}
f = last.compile(ast)
print(f(2)) -- output: 3
y = 40
print(f(2)) -- output: 42
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semantics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{sec:semantics}

In this section, we specify below the behavior of toAST() and compile()
by using the formalization of a subset of Lua semantics, presented
in \cite{DeVito2013Terra} as Lua Core. We use the same formal framework
of that work in order to properly compare and contrast our approach
for multi-stage programming to that employed by Terra.

Lua Core depicts the notions of lexical scoping, closures and side-effects
present in Lua, and is therefore mostly sufficient for our purposes.
We extend this specification with an arbitrary ``binary operator''
expression, mimicking Lua operators supported by Lua2AST. This way,
we have a recursive rule through which we can model Lua expressions
as trees, to be later converted to ASTs. We also include toAST() and
compile() as core language operations so we can specify their semantics
separately from plain functions.

\begin{figure}[t]
\begin{eqnarray*}
e & = & b\,|\, x\,|\,\mbox{let \ensuremath{x=e}\,\ in\,\ensuremath{e}}\,|\, x\coloneqq e\,|\, e(e)\,|\,\mbox{fun}(x)\{e\}\,|\, e\mbox{ op }e\,|\,\mbox{toAST}(e)\,|\,\mbox{compile}(a)\\
v & = & b\,|\,\left\langle \Gamma,x,e\right\rangle \,|\, a\\
a & = & [\mbox{fn\,\ensuremath{x}\,\ensuremath{a}}]\,|\,[\mbox{base \ensuremath{b}}]\,|\,[\mbox{var}\, x\,\left\langle \Gamma,x,e\right\rangle ]\,|\,[\mbox{op\,\ensuremath{a}\,\ensuremath{a}}]
\end{eqnarray*}
\protect\caption{\label{fig:LuaCoreSyntax}Syntax of our version of Lua Core, extended
with constructs to specify Lua2AST}
\end{figure}

\begin{figure}[!t]
{\footnotesize{}}%
\begin{minipage}[t]{0.59\columnwidth}%
{\footnotesize{}
\[
v,\Sigma\overset{L}{\rightarrow}v,\Sigma\textsc{ (LVal)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\Sigma=(\Gamma,S)}{x,\Sigma\overset{L}{\rightarrow}S(\Gamma(x)),\Sigma}\textsc{ (LVar)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
e_{1},\Sigma_{1}\overset{L}{\rightarrow}v_{1},(\Gamma_{2},S_{2})\,\,\,\,\,\,\,\, p\,\mbox{fresh}\\
e_{2},(\Gamma_{2}[x\leftarrow p],S_{2}[p\leftarrow v_{1}])\overset{L}{\rightarrow}v_{2},(\Gamma_{3},S_{3})
\end{array}}{\mbox{let \ensuremath{x=e_{1}}\,\ in\,\ensuremath{e_{2}}},\Sigma_{1}\overset{L}{\rightarrow}v_{2},(\Gamma_{2},S_{3})}\textsc{ (LLet)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
e_{1},\Sigma_{1}\overset{L}{\rightarrow}\left\langle \Gamma_{1},x,e_{3}\right\rangle ,\Sigma_{2}\\
e_{2},\Sigma_{2}\overset{L}{\rightarrow}v_{1},(\Gamma_{3},S_{3})\,\,\,\,\,\,\,\,\mbox{\ensuremath{p}\ fresh}\\
e_{3},(\Gamma_{1}[x\leftarrow p],S_{3}[p\leftarrow v_{1}])\overset{L}{\rightarrow}v_{2},(\Gamma_{4},S_{4})
\end{array}}{e_{1}(e_{2}),\Sigma_{1}\overset{L}{\rightarrow}v_{2},(\Gamma_{3},S_{4})}\textsc{ (LApp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e_{1},\Sigma_{1}\overset{L}{\rightarrow}v_{1},(\Gamma,S)\,\,\,\,\,\,\,\,\Gamma(x)=p}{x\coloneqq e,\Sigma\overset{L}{\rightarrow}v,(\Gamma,S[p\leftarrow v])}\textsc{ (LAsn)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\Sigma=(\Gamma,S)}{\mbox{fun(\ensuremath{x})\{\ensuremath{e}\}},\Sigma\overset{L}{\rightarrow}\left\langle \Gamma,x,e\right\rangle ,\Sigma}\textsc{ (LFun)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
e_{1},\Sigma_{1}\overset{L}{\rightarrow}v_{1},\Sigma_{2}\,\,\,\,\,\,\,\, e_{2},\Sigma_{2}\overset{L}{\rightarrow}v_{2},\Sigma_{3}\\
v_{3}=Op(v_{1},v_{2})
\end{array}}{e_{1}\mbox{\, op\,}e_{2},\Sigma_{1}\overset{L}{\rightarrow}v_{3},\Sigma_{3}}\textsc{ (LOp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e_{1},\Sigma_{1}\overset{L}{\rightarrow}\left\langle \Gamma,x,e_{2}\right\rangle ,\Sigma_{2}\,\,\,\,\,\,\,\,\left\langle \Gamma,x,e_{2}\right\rangle ,\Sigma_{2}\overset{D}{\rightarrow}a}{\mbox{toAST(\ensuremath{e_{1}})},\Sigma_{1}\overset{L}{\rightarrow}a,\Sigma_{2}}\textsc{ (LAst)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{a,\Sigma_{1}\overset{C}{\rightarrow}e,\Sigma_{2}}{\mbox{compile(\ensuremath{a})},\Sigma_{1}\rightarrow e,\Sigma_{2}}\textsc{ (LComp)}
\]
}%
\end{minipage}{\footnotesize{}}%
\begin{minipage}[t]{0.4\columnwidth}%
{\footnotesize{}
\[
b,\Sigma\overset{D}{\rightarrow}[\mbox{base }b]\textsc{ (DBase)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
\Sigma=(\Gamma,S)\\
x'\,\mbox{fresh}
\end{array}}{x,\Sigma\overset{D}{\rightarrow}[\mbox{var }x'\,\left\langle \Gamma,\_,x\right\rangle ]}\textsc{ (DVar)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e_{1},\Sigma\overset{D}{\rightarrow}a_{1}\,\,\,\,\,\,\,\, e_{2},\Sigma\overset{D}{\rightarrow}a_{2}}{e_{1}\mbox{ op }e_{2},\Sigma\overset{D}{\rightarrow}[\mbox{op\,\ensuremath{a_{1}\,}\ensuremath{a_{2}}}]}\textsc{ (DOp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e,\Sigma\overset{D}{\rightarrow}a}{\left\langle \Gamma,x,e\right\rangle ,\Sigma\overset{D}{\rightarrow}[\mbox{fn }x\, a]}\textsc{ (DFn)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
[\mbox{base \ensuremath{b}}],\Sigma\overset{C}{\rightarrow}b,\Sigma\textsc{ (CBase)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
\Sigma_{1}=(\Gamma,S)\\
p\,\mbox{fresh}\\
\Sigma_{2}=(\Gamma[x'\leftarrow p],S[p\leftarrow f])
\end{array}}{[\mbox{var }x'\, f],\Sigma_{1}\overset{C}{\rightarrow}x'(\_),\Sigma_{2}}\textsc{ (CVar)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{a_{1},\Sigma_{1}\overset{C}{\rightarrow}e_{1},\Sigma_{2}\,\,\,\,\,\,\,\, a_{2},\Sigma_{2}\overset{C}{\rightarrow}e_{2},\Sigma_{3}}{[\mbox{op\,\ensuremath{a_{1}}\ensuremath{\, a_{2}}}],\Sigma_{1}\overset{C}{\rightarrow}e_{1}\mbox{ op }e_{2},\Sigma_{3}}\textsc{ (COp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
\Sigma_{1}=(\Gamma_{1},S_{1})\\
a,\Sigma_{1}\overset{C}{\rightarrow}e,(\Gamma_{2},S_{2})
\end{array}}{[\mbox{fn }x\, a],\Sigma_{1}\overset{C}{\rightarrow}\left\langle \Gamma_{2},x,e\right\rangle ,(\Gamma_{1},S_{2})}\textsc{ (CFn)}
\]
}%
\end{minipage}{\footnotesize \par}

\protect\caption{\label{fig:Semantics}Rules $\protect\overset{L}{\rightarrow}$ for
the evaluation of Lua expressions, $\protect\overset{D}{\rightarrow}$
for decompiling Lua expressions into ASTs, and $\protect\overset{C}{\rightarrow}$
for compiling ASTs back into expressions.}
\end{figure}



The syntax of our version of Lua Core is presented in Figure \ref{fig:LuaCoreSyntax}.
Lua expressions ($e$) can be base values ($b$), variables ($x$),
a scoped variable definition ($\mbox{let \ensuremath{x=e}\,\ in\,\ensuremath{e}}$,
with $e;e$ as sugar for $\mbox{let \ensuremath{\_=e}\,\ in\,\ensuremath{e}}$),
a variable assignment ($x\coloneqq e$), an application ($e(e)$),
a function definition ($\mbox{fun}(x)\{e\}$) or an operation on expressions
($e\mbox{ op }e$, with semantics defined by a function $Op$). We
extend this by adding operations \emph{toAST($e$)} and \emph{compile($a$)}.
Lua values ($v$) can be base values ($b$), closures ($\left\langle \Gamma,x,e\right\rangle $)
or Lua ASTs ($a$). A Lua AST for a function consists of a root node
($[\mbox{fn\,\ensuremath{x}\,\ensuremath{a}}]$) which may contain
nodes that wrap base values\emph{ }($[\mbox{base }b]$\emph{), }variables
($[\mbox{var }x\,\left\langle \Gamma,x,e\right\rangle ]$) and operations
($[\mbox{op}\, a\, a]$).

In Figure \ref{fig:Semantics}, we present the rules for evaluating
Lua Core over an environment $\Sigma$, which is a tuple $(\Gamma,S)$
containing a namespace $\Gamma:x\rightarrow p$ and a store $S:p\rightarrow v$
(where $p$ are memory positions). We use $\overset{L}{\rightarrow}$
for the evaluation of Lua expressions as in \cite{DeVito2013Terra};
where rules have the same names, they have the same semantics as those
presented in that work. We added rules \textsc{LOp} for the binary
operation, \textsc{LAst} for the $toAST()$ function and \textsc{LComp}
for the \emph{compile}() function.

We also add two other relations: rules for decompiling a Lua function
into an AST ($\overset{D}{\rightarrow}:(e\times\Sigma)\rightarrow a$)
and rules for compiling ASTs back into Lua functions ($\overset{C}{\rightarrow}:(a\times\Sigma)\rightarrow(e\times\Sigma)$).
In our formalization, decompiling the function produces an AST but
does not affect the environment; all values produced are stored in
the AST itself. Compiling returns an environment with an unmodified
namespace and a modified store which includes the required closures. 

Note that $\overset{D}{\rightarrow}$ is defined only for variables
(\textsc{DVar}), base values (\textsc{DBase}), the binary operator
(\textsc{DOp}), and the initial function (\textsc{DFn}), mirroring
the implementation of \emph{toAST}() in LuaToAST. Its rules deconstruct
the body of the function and build the corresponding AST. Of particular
interest is rule \textsc{DVar}, which stores in the AST node a fresh
variable $x'$ (i.e. one guaranteed not to exist in $\Gamma$) and
a newly created closure, which returns the value of $x$ given the
original function's environment. In the complementary rule \textsc{CVar},
this new variable $x'$ is assigned in the resulting environment to
hold the node's closure $f$. Note in rule \textsc{CFn} that the derived
namespace $\Gamma_{2}$ is used only in the resulting closure, whereas
the derived store $S_{2}$ is used in the resulting environment. In
$\Gamma_{2}$, all variable references that existed in the original
function that was decompiled and now recompiled were replaced by calls
to newly-created closures that merely return the value of the corresponding
variables.

These closures use the original namespace from decompilation time
($\Gamma$ in \textsc{DVar}), so the variable references are bound
to the addresses they have in the lexical scope where decompilation
takes place. Any variable $x$ stored in an AST will only be evaluated
when the compiled function returned by $compile(a)$ is called, and
the call to wrapper closure $x'()$ will ensure that $x$ is tied
to its original namespace.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{splncs_srt}
\bibliography{sblp2015}

\end{document}
