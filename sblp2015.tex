\documentclass[english]{llncs}

\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{babel}

\title{Embedding Languages Preserving Lexical Scoping}

\author{
Félix Ribeiro,
Hisham Muhammad,
André Murbach Maidl,
Roberto Ierusalimschy
}

\institute{
Department of Computer Science --
PUC-Rio -- Rio de Janeiro -- Brazil
\email{\{fribeiro,hisham,amaidl,roberto\}@inf.puc-rio.br}
}

\begin{document}

\maketitle

\begin{abstract}
\keywords{
Lua,
Domain Specific Languages,
Embedded Languages
}
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lua2AST}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Lua2AST is a Lua module that takes a restricted form of Lua function, that we named lambda functions, and generates its AST in runtime.
Lambda functions is defined here as functions that only contains the return statement.
The expression contained in the return statement can be of any kind and can also use variables of the outer lexical scope.
In Lua, this kind of variables are called upvalues.
The process of generation uses externs libraries: luadec and lua-parser.
Luadec\cite{TODO} is a Lua decompiler that takes a Lua binary chunk and returns a string with equivalent code.
Lua-parser\cite{TODO} generates a Lua AST from a string with a valid Lua code.

%% TODO : detalhar o pq do uso do luadec - diferenciar dos related works
%% explicitando as vantagens de utilizar o LuaDec
%% Menos intruzivo no codigo fonte(nao precisam ser anotadas) e mais no background
%% nao tem modificacao na virtual machine 
%% linguagem eh dinamica - ela tem eval (alem de ser dinamicamente tipada) - facilidade provida pela linguagem
%% nossa abordagem ela integra bem com as caracteristicas dinamicas da linguagem
%% o q nao seria possivel se fosse feita atraves de preprocessador
%% pontuar q o processo inteiro ocorre em tempo de execucao
This module contains two principal functions: toAST e compile.
The first one generates an AST and the second one compiles an AST.

\subsection{Function toAST(func) }

The parameter func must be a lambda function.
The function's return is a Lua table that represents an AST.
If the received function uses upvalues the returned table will be an annotated AST,so that the upvalues can be evaluated properly.

The toAST(func) function calls the function luadec(arg) that belongs to libluadec, sending the function that will be transformed in AST as argument.
The return of the luadec(arg) is a string that represents the passed function code.
This string is sent to the parse function of lua-parser library and it returns the AST that represents the code.

The received AST is traversed once.
Firstly we find the parameters of the function and store them in a set.
Later, we localize the free variables of the  function and when they are found a execution code lookup is made with the standard library debug.

The lookup consists in going through the upvalues that belongs to the function that was sent to toAST in order to find the variable of the same name.
When the variable is found, we do the AST annotation process.

To do this annotation in our AST we use the function upvaluejoin, that also belongs to the debug library.
This function joins two upvalues of distinct functions.
But, to use this function, we need another one to join the upvalues. To do so, we created the functions that follows:


\pagebreak
\begin{verbatim}
local function newclosure()
    local temp
    return function () return temp end
end
\end{verbatim}

So, when an upvalue is found, the newclosure function is called, then its return is assigned to a variable and the found upvalue is joint to the temp upvalue.
After pulling them together, we generate an unique identifier to the function returned by newclosure.
We replace in the AST the node that identifies the free variable by an upvalue node.
In this node is inserted the function with unique identifier generated by upvalue.


The following example illustrates the use of the toAST function:


\begin{verbatim}
local last = require "lua-to-AST"

local y = 1
ast = last.toAST(function(x) return x + y end )
last.print(ast)
\end{verbatim}


The program's output will be the AST print, as below:
%% Verificar higienizacao de variaveis
\begin{verbatim}
{ `Function{ { `Id "x" },
      { `Return{ `Op{ "add", `Id "x", `UpValue "clo_0"}}}}}}
\end{verbatim}


\subsection{Function compile(ast) }


%% completar exemplo da secao anterior
%% mostrar string interna 
This function receives as argument the AST generated by toAST and returns the function that this AST describes.

The AST received is encapsulated in a return node and then a string with correspondent Lua code is generated.Using the AST above to examplify, its correspondent string would be as follows:


%% TODO : higenizacao
\begin{verbatim}
"function(x) return x + closures["clo_0"]() end"
\end{verbatim}

This string is sent to the loadstring function.
The function compile returns the result of loadstring.
In this way the user can utilize the returned function that is the compilation of the AST.
Bellow we show an example of using the compile function, it uses the AST that was previously generated.


\begin{verbatim}
f = last.compile(ast)
print(f(2)) -- output: 3
y = 40
print(f(2)) -- output: 42
\end{verbatim}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semantics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{sec:evaluation_semantics}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
{\footnotesize{}}%
\begin{minipage}[t]{0.59\columnwidth}%
{\footnotesize{}
\[
v,\Sigma\rightarrow v,\Sigma\textsc{ (LVal)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\Sigma=(\Gamma,S)}{x,\Sigma\rightarrow S(\Gamma(x)),\Sigma}\textsc{ (LVar)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
e_{1},\Sigma_{1}\rightarrow v_{1},(\Gamma_{2},S_{2})\\
p\,\mbox{fresh}\\
e_{2},(\Gamma_{2}[x\leftarrow p],S_{2}[p\leftarrow v_{1}])\rightarrow v_{2},(\Gamma_{3},S_{3})
\end{array}}{\mbox{let \ensuremath{x=e_{1}}\,\ in\,\ensuremath{e_{2}}},\Sigma_{1}\rightarrow v_{2},(\Gamma_{2},S_{3})}\textsc{ (LLet)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
e_{1},\Sigma_{1}\rightarrow\left\langle \Gamma_{1},x,e_{3}\right\rangle ,\Sigma_{2}\\
e_{2},\Sigma_{2}\rightarrow v_{1},(\Gamma_{3},S_{3})\\
\mbox{\ensuremath{p}\,\ fresh}\\
e_{3},(\Gamma_{1}[x\leftarrow p],S_{3}[p\leftarrow v_{1}])\rightarrow v_{2},(\Gamma_{4},S_{4})
\end{array}}{e_{1}(e_{2}),\Sigma_{1}\rightarrow v_{2},(\Gamma_{3},S_{4})}\textsc{ (LApp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e_{1},\Sigma_{1}\rightarrow v_{1},(\Gamma,S)\,\,\,\,\,\,\,\,\,\,\Gamma(x)=p}{x\coloneqq e,\Sigma\rightarrow v,(\Gamma,S[p\leftarrow v])}\textsc{ (LAsn)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\Sigma=(\Gamma,S)}{\mbox{fun(\ensuremath{x})\{\ensuremath{e}\}},\Sigma\rightarrow\left\langle \Gamma,x,e\right\rangle ,\Sigma}\textsc{ (LFun)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
e_{1},\Sigma_{1}\rightarrow v_{1},\Sigma_{2}\,\,\,\,\,\,\,\,\,\, e_{2},\Sigma_{2}\rightarrow v_{2},\Sigma_{3}\\
v_{3}=Op(v_{1},v_{2})
\end{array}}{e_{1}\mbox{\,\ op\,}e_{2},\Sigma_{1}\rightarrow v_{3},\Sigma_{3}}\textsc{ (LOp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e_{1},\Sigma\rightarrow\left\langle \Gamma,x,e_{2}\right\rangle ,\Sigma\,\,\,\,\,\,\,\,\,\,\left\langle \Gamma,x,e_{2}\right\rangle ,\Sigma\overset{D}{\rightarrow}a}{\mbox{toAST(\ensuremath{e_{1}})},\Sigma\rightarrow a,\Sigma}\textsc{ (LAst)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\Sigma=(\Gamma,S)\,\,\,\,\,\,\,\,\,\, a,\Sigma\overset{C}{\rightarrow}e}{\mbox{compile(\ensuremath{a})},\Sigma\rightarrow e,\Sigma}\textsc{ (LComp)}
\]
}%
\end{minipage}{\footnotesize{}}%
\begin{minipage}[t]{0.4\columnwidth}%
{\footnotesize{}
\[
b,\Sigma\overset{D}{\rightarrow}[\mbox{base }b]\textsc{ (DBase)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\Sigma=(\Gamma,S,F)}{x,\Sigma\overset{D}{\rightarrow}[\mbox{var }\left\langle \Gamma,\_,x\right\rangle ]}\textsc{ (DVar)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e_{1},\Sigma\overset{D}{\rightarrow}a_{1}\,\,\,\,\,\,\,\,\,\, e_{2},\Sigma\overset{D}{\rightarrow}a_{2}}{e_{1}\mbox{ op }e_{2},\Sigma\overset{D}{\rightarrow}[\mbox{op\,\ensuremath{a_{1}\,}\ensuremath{a_{2}}}]}\textsc{ (DOp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{e,\Sigma\overset{D}{\rightarrow}a}{\left\langle \Gamma,x,e\right\rangle ,\Sigma\overset{D}{\rightarrow}[\mbox{fn }x\, a]}\textsc{ (DFn)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
[\mbox{base \ensuremath{b}}],\Sigma\overset{C}{\rightarrow}b,\Sigma\textsc{ (CBase)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{\begin{array}[t]{c}
\Sigma=(\Gamma,S)\\
e_{1},(\Gamma_{1},S)\rightarrow v_{1},\Sigma_{2}
\end{array}}{[\mbox{var }\left\langle \Gamma_{1},\_,e_{1}\right\rangle ],\Sigma\overset{C}{\rightarrow}v_{1}}\textsc{ (CVar)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{a_{1},\Sigma\overset{C}{\rightarrow}e_{1}\,\,\,\,\,\,\,\,\,\, a_{2},\Sigma\overset{C}{\rightarrow}e_{2}}{[\mbox{op\,\ensuremath{a_{1}}\ensuremath{\, a_{2}}}],\Sigma\overset{C}{\rightarrow}e_{1}\mbox{ op }e_{2}}\textsc{ (COp)}
\]
}{\footnotesize \par}

{\footnotesize{}
\[
\frac{a,\Sigma\overset{C}{\rightarrow}e}{[\mbox{fn }x\, a],\Sigma\overset{C}{\rightarrow}\left\langle \Gamma,x,e\right\rangle }\textsc{ (CFn)}
\]
}%
\end{minipage}{\footnotesize \par}

\protect\caption{Rules $\rightarrow$ for the evaluation of Lua expressions, $\protect\overset{D}{\rightarrow}$
for decompiling Lua expressions into ASTs, and $\protect\overset{C}{\rightarrow}$
for compiling ASTs back into expressions.}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We specify below the behavior of toAST() and compile() by using the
formalization of a subset of Lua semantics, as presented (as Lua Core)
in \cite{DeVito2013Terra}. This subset depicts the notions of lexical scoping,
closures and side-effects and is therefore sufficient for our purposes.
We extend the Lua Core specification from \cite{DeVito2013Terra} with a general
``binary operator'' expression, mimicking Lua operators supported
by LuaToAST.

Lua Core syntax is presented as follows:

\[
e=b\,|\, x\,|\,\mbox{let \ensuremath{x=e}\,\ in\,\ensuremath{e}}\,|\, x\coloneqq e\,|\, e(e)\,|\,\mbox{fun}(x)\{e\}\,|\, e\mbox{ op }e\,|\,\mbox{toAST}(e)\,|\,\mbox{compile}(a)
\]


Lua expressions can be base values ($b$), variables ($x$), a scoped
variable definition ($\mbox{let \ensuremath{x=e}\,\ in\,\ensuremath{e}}$,
with $e;e$ as sugar for $\mbox{let \ensuremath{\_=e}\,\ in\,\ensuremath{e}}$),
a variable assignment ($x\coloneqq e$), an application ($e(e)$),
a function definition ($\mbox{fun}(x)\{e\}$) or an operation on expressions
($e\mbox{ op }e$, with semantics defined by a function $Op$). We
extend this by adding operations toAST($e$) and compile($a$).

\[
v=b\,|\,\left\langle \Gamma,x,e\right\rangle \,|\, a
\]


Lua values can be base values ($b$), closures ($\left\langle \Gamma,x,e\right\rangle $)
or Lua ASTs ($a$).

\[
a=[\mbox{fn\,\ensuremath{x}\,\ensuremath{a}}]\,|\,[\mbox{base \ensuremath{b}}]\,|\,[\mbox{var }\left\langle \Gamma,x,e\right\rangle ]\,|\,[\mbox{op\,\ensuremath{a}\,\ensuremath{a}}]
\]


A Lua AST for a function consists of a root node ($[\mbox{fn\,\ensuremath{x}\,\ensuremath{a}}]$)
which may contain nodes that wrap base values\emph{ }($[\mbox{base }b]$\emph{),
}variables ($[\mbox{var }\left\langle \Gamma,x,e\right\rangle ]$)
and operations ($[\mbox{op}\, a\, a]$).

The rules for evaluating Lua expressions over an environment $\Sigma$,
which is a tuple $(\Gamma,S)$ containing a namespace $\Gamma:x\rightarrow p$
and a store $S:p\rightarrow v$ (where $p$ are memory positions)
are as follows. We use $\rightarrow$ instead of $\overset{L}{\rightarrow}$
as in \cite{DeVito2013Terra}; where rules have the same names, they have the
same semantics as those presented in that work.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{splncs_srt}
\bibliography{sblp2015}

\end{document}
